<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>





  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><title>Using pseudo-terminals to control interactive programs, pty, pdip</title>
  
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="author" content="rachid koucha">
  <meta name="Category" content="pty, pseudo-terminal, pdip, linux, interactive programs">
  <meta name="language" content="en">
  <meta http-equiv="Content-Language" content="en">
  <meta name="description" content="How to use pseudo-terminals (pty) to control interactive programs. This is an introduction to PDIP.">
  <meta name="keywords" content="pty, pseudo-terminal, pdip, input output redirection, processus, linux, telnet">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.41cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.41cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.41cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
--> </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.41cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <meta http-equiv="CONTENT-TYPE" content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="OpenOffice.org 2.3 (Linux)">
  <style type="text/css">
<!--
@page { size: 21cm 29.7cm; margin: 2cm }
P { margin-bottom: 0.21cm }
-->
  </style>
  <script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script></head><body>
<small><small><span style="text-decoration: underline;">Author</span>:
R. Koucha<br>
<span style="text-decoration: underline;">Last update</span>: 16-Apr-2014<br>
<br>
</small></small><small><br>
<a href="http://rachid.koucha.free.fr/index.html">Back to home
page</a><br>
<a href="../technical_documents.html">Back to previous
page</a></small>
<br>
<h1 style="text-align: center;">Using pseudo-terminals (pty) to
control interactive programs</h1>
<table style="text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(192, 192, 192);">
  <tbody>
    <tr>
      <td>
      <script type="text/javascript"><!--
google_ad_client = "pub-9113501896220746";
/* 728x90, date de création 29/03/08 */
google_ad_slot = "7632855209";
google_ad_width = 728;
google_ad_height = 90;
//--></script>
      <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<br>
<table style="text-align: left; width: 100%;" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; height: 50%; width: 50%;"><br>
      </td>
      <td style="vertical-align: top;"><iframe src="http://www.facebook.com/plugins/like.php?href=http%3A%2F%2Frachid.koucha.free.fr%2Ftech_corner%2Fpty_pdip.html&amp;layout=standard&amp;show_faces=true&amp;width=450&amp;action=like&amp;colorscheme=light&amp;height=80" style="border: medium none ; overflow: hidden; width: 450px; height: 80px;" allowtransparency="true" frameborder="0" scrolling="no"></iframe> <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><g:plusone size="medium"></g:plusone>
      <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><a href="mailto:?body=http%3A%2F%2Frachid.koucha.free.fr%2Ftech_corner%2Fpty_pdip.html&amp;subject=Using%20pseudo-terminals%20%28pty%29%20to%20control%20interactive%20programs"><img alt="s" src="../send_to_a_friend.gif" style="border: 0px solid ; width: 30px; height: 21px;"></a></td>
    </tr>
  </tbody>
</table>
<br>
<a href="#Foreword">Foreword</a><br>
<a href="#Introduction">Introduction</a><br>
<a href="#Redirection_of_the_standard_input_and">Redirection
of the standard input and outputs of a process</a><br>
<a href="#Problems_while_automating_interactive">Problems
while automating interactive programs</a><br>
<a href="#Introduction_to_pseudo-terminals">Introduction
to pseudo-terminals</a><br>
<div style="margin-left: 40px;"><a href="#API_of_the_pseudo-terminals">API
of
the
pseudo-terminals</a><br>
</div>
<a href="#Usage_of_the_pseudo-terminals">Usage of the
pseudo-terminals</a><br>
<div style="margin-left: 40px;"><a href="#Inter-process_communication_through_a">Inter-process
communication through a pseudo-terminal</a><br>
<a href="#Limitation_of_grantpt">Limitation of grantpt()</a><br>
<a href="#Taking_control_over_an_interactive">Taking
control over an interactive process</a><br>
</div>
<a href="#Presentation_of_pdip">Presentation of pdip</a><br>
<div style="margin-left: 40px;"><a href="#Using_pdip">Using
pdip</a><br>
</div>
<a href="#Resources">Resources</a><br>
<a href="#About_the_author">About the author</a><br>
<h2><a name="Foreword"></a>Foreword</h2>
<br>
A french version of this article has been published in <a href="http://www.unixgarden.com/index.php/programmation/utilisation-des-pseudo-terminaux-pour-piloter-les-programmes-interactifs"><img alt="glmf_logo" src="../glmf_logo.jpg" style="border: 0px solid ; width: 100px; height: 30px;"></a> special issue 34.<br>

<h2><a name="Introduction"></a>Introduction</h2>
Although less and less popular, the interactive applications in command
line mode interacting with an operator through a terminal on a serial
port, are still widely used. Especially in the embedded world where the
graphical resources are superfluous or too expensive. Among those
applications, we can quote as examples:<br>
<ul>
  <li><span style="color: rgb(255, 0, 0);">bash</span>:
the default Linux shell</li>
  <li><span style="color: rgb(255, 0, 0);">bc</span>:
the calculator</li>
  <li><span style="color: rgb(255, 0, 0);">ftp</span>:
file transfer utility</li>
  <li><span style="color: rgb(255, 0, 0);">telnet</span>:
remote terminal</li>
</ul>
It is possible to use those tools in shell scripts in order
to&nbsp;automate some tasks like tests or system maintenance and
administration. For example, we could use telnet in a script to connect
to a remote machine to trigger some operations. Unfortunately, this is
not that simple because an interactive program needs a human to operate.<br>
<br>
This article focuses on a solution based on pseudo-terminals to
automate interactive programs.<br>
<br>
<br>
<h2><a name="Redirection_of_the_standard_input_and"></a>Redirection
of the standard input and outputs of a process</h2>
<div style="text-align: justify;">Once a program is loaded
into memory
to be executed, it becomes a process attached to the current terminal.
By default, the standard input (<span style="font-weight: bold;">stdin</span>)
comes
from
the&nbsp;
keyboard
and
the
standard
outputs
(<span style="font-weight: bold;">stdout</span>
and <span style="font-weight: bold;">stderr</span>) are
redirected to the screen (cf. <a href="#figure_1">figure 1</a>).<br>
</div>
<br>
<h6 style="text-align: center;"><span style="text-decoration: underline;"><a name="figure_1"></a>Figure
1</span>: Standard input and outputs of a Linux process</h6>
<div style="text-align: center;"><img style="width: 255px; height: 234px;" alt="figure 1" src="pty_pdip_figure_1.jpg"></div>
<div style="text-align: center;">
<div style="text-align: justify;"><br>
Linux
provides the ability to redirect the standard input and outputs in
order to get data from another source than the keyboard and display
data to another destination than the screen. This feature is very
powerful: a process reads its standard input and writes to its standard
outputs without knowing any details about the devices. In other words,
a program can run without any modifications to read from the keyboard
or a file or the output of another process (<span style="font-weight: bold;">pipe</span> mechanism). It
is the same for the outputs.<br>
Let's consider the following program called <span style="color: rgb(255, 0, 0); font-style: italic;">mylogin</span>
which gets a login name and a password:<br>
<br>
<table style="font-family: monospace; text-align: left; background-color: rgb(204, 255, 255); width: 530px; height: 417px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="height: 100%; width: 100%; text-align: left; vertical-align: middle;">
      <font style="font-size: 9pt;" size="2">#include
&lt;stdio.h&gt;</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">int
main(void)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">char&nbsp;login_name[150];</font>
      <br>
      <font style="font-size: 9pt;" size="2">char&nbsp;password[150];</font>
      <br>
      <br>
      <font style="font-size: 9pt;" size="2">// By
default stdin, stdout and stderr are open</font><br>
      <br>
      <font style="font-size: 9pt;" size="2">fprintf(stdout,
"Login : ");</font> <br>
      <font style="font-size: 9pt;" size="2">if
(NULL == fgets(login_name, sizeof(login_name), stdin))</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"No login name\n");</font> <br>
      <font style="font-size: 9pt;" size="2">return
1;</font> <br>
      <font style="font-size: 9pt;" size="2">}</font><br>
      <br>
      <font style="font-size: 9pt;" size="2">fprintf(stdout,
"Password : ");</font> <br>
      <font style="font-size: 9pt;" size="2">if
(NULL == fgets(password, sizeof(password), stdin))</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"No password\n");</font><br>
      <font style="font-size: 9pt;" size="2">return
1;</font><br>
      <font style="font-size: 9pt;" size="2">}</font><br>
      <br>
      <font style="font-size: 9pt;" size="2">fprintf(stdout,
"Result :\n%s%s\n", login_name, password);</font><br>
      <br>
      <font style="font-size: 9pt;" size="2">return
0;</font><br>
      <font style="font-size: 9pt;" size="2">}</font> </td>
    </tr>
  </tbody>
</table>
<br>
Under a shell like bash, multiple
solutions are available to make redirections. If we launch the program
as it is, the input is the keyboard and the outputs are the screen.<br>
<br>
<table style="text-align: left; width: 156px; height: 117px; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(204, 255, 255);"> <font><font style="font-size: 9pt;" size="2">$
./mylogin</font></font> <br>
      <font><font style="font-size: 9pt;" size="2">Login
: bar</font></font> <br>
      <font><font style="font-size: 9pt;" size="2">Password
: foo</font></font> <br>
      <font><font style="font-size: 9pt;" size="2">Result
:</font></font><br>
bar<br>
      <font><font style="font-size: 9pt;" size="2">foo</font></font> <br>
      <font><font style="font-size: 9pt;" size="2">$</font></font> </td>
    </tr>
  </tbody>
</table>
<br>
The preceding program can be launched as follow to redirect the output
to the file output.txt.<br>
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 226px; height: 132px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">$
./mylogin &gt; output.txt</font> <br>
      <span style="font-family: mon;">bar</span> <br>
      <font style="font-size: 9pt;" size="2">foo</font> <br>
      <font style="font-size: 9pt;" size="2">$
cat output.txt</font> <br>
      <font style="font-size: 9pt;" size="2">Login
: Password : Result :</font> <br>
      <span style="font-family: mon;">bar</span><br>
      <font style="font-size: 9pt;" size="2">foo</font> <br>
      <font style="font-size: 9pt;" size="2">$</font> </td>
    </tr>
  </tbody>
</table>
<br>
We can see that without any modifications in the program <span style="font-style: italic; color: rgb(255, 0, 0);">mylogin</span>,
it has been possible to launch it to have the standard output
redirected to the screen and then to the file <span style="font-style: italic;">output.txt</span>.<br>
<br>
<h2><a name="Problems_while_automating_interactive"></a>Problems
while automating interactive programs</h2>
A
program as simple as <span style="font-style: italic; color: red;">mylogin</span> can be automated. That is to say that
the human operator can be replaced by a program like a shell script.
Let's consider the file <span style="font-style: italic;">input.txt</span>
into which we have stored the answers expected by <span style="font-style: italic; color: rgb(255, 0, 0);">mylogin</span>.<br>
<br>
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 121px; height: 72px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">$
cat input.txt</font> <br>
      <span style="font-family: mon;">bar</span> <br>
      <font style="font-size: 9pt;" size="2">foo</font> <br>
      <font style="font-size: 9pt;" size="2">$</font> </td>
    </tr>
  </tbody>
</table>
<br>
We can launch <span style="font-style: italic; color: red;">mylogin</span> with <span style="font-style: italic;">input.txt</span> as standard input:<br>
<br>
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 207px; height: 87px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">$
./mylogin &lt; input.txt</font> <br>
      <font style="font-size: 9pt;" size="2">Login
: Password : Result :</font> <br>
      <span style="font-family: mon;">bar</span><br>
      <font style="font-size: 9pt;" size="2">foo</font><br>
      <font style="font-size: 9pt;" size="2">$</font> <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
So, we have replaced the human operator
by a file containing the expected entries. Unfortunately, it is not
possible to apply this method to all interactive programs. Some of them
are very elaborated. A program reading a password typically flushes its
standard input right after having displayed the password prompt to get
rid of any characters entered between the login name and the password
prompt (the character echoing is also deactivated during the password
entry). We can illustrate this by making <span style="font-style: italic; color: rgb(255, 0, 0);">mylogin</span>
flush its standard input just before the password entry (call to
fseek()).<br>
<br>
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 456px; height: 462px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">#include
&lt;stdio.h&gt;</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">int
main(void)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">char&nbsp;login_name[150];</font>
      <br>
      <font style="font-size: 9pt;" size="2">char&nbsp;password[150];</font>
      <br>
      <br>
      <font style="font-size: 9pt;" size="2">// By
default stdin, stdout and stderr are open</font><br>
      <br>
      <font style="font-size: 9pt;" size="2">fprintf(stdout,
"Login : ");</font> <br>
      <font style="font-size: 9pt;" size="2">if
(NULL == fgets(login_name, sizeof(login_name), stdin))</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"No login name\n");</font> <br>
      <font style="font-size: 9pt;" size="2">return
1;</font> <br>
      <font style="font-size: 9pt;" size="2">}</font><br>
      <font style="font-size: 9pt;" size="2"><font color="#ff0000"><font style="font-size: 9pt;" size="2"><br>
// Flush standard input</font></font></font><br>
      <font style="font-size: 9pt;" size="2"><font color="#ff0000"><font style="font-size: 9pt;" size="2">fseek(stdin,
0, SEEK_END);</font></font></font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">fprintf(stdout,
"Password : ");</font> <br>
      <font style="font-size: 9pt;" size="2">if
(NULL == fgets(password, sizeof(password), stdin))</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"No password\n");</font><br>
      <font style="font-size: 9pt;" size="2">return
1;</font><br>
      <font style="font-size: 9pt;" size="2">}</font><br>
      <br>
      <font style="font-size: 9pt;" size="2">fprintf(stdout,
"Result :\n%s%s\n", login_name, password);</font><br>
      <br>
      <font style="font-size: 9pt;" size="2">return
0;</font><br>
      <font style="font-size: 9pt;" size="2">}</font></td>
    </tr>
  </tbody>
</table>
<br>
When interacting with the operator, the program behaves the same (the
keyboard is the standard input).<br>
<br>
<table style="text-align: left; font-family: monospace; background-color: transparent; width: 153px; height: 102px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(204, 255, 255);"> <font style="font-size: 9pt;" size="2">$
./mylogin</font><br>
      <font style="font-size: 9pt;" size="2">login
: bar</font><br>
      <font style="font-size: 9pt;" size="2">Password
: foo</font><br>
      <font style="font-size: 9pt;" size="2">La
saisie est :</font><br>
      <span style="font-family: mon;">bar</span><br>
      <font style="font-size: 9pt;" size="2">foo</font> </td>
    </tr>
  </tbody>
</table>
<br>
On the other side, when the standard input is a file, the error message
<span style="font-style: italic;">"No password"</span>
is displayed. Actually, the second call to <span style="font-style: italic;">fread()</span> gets an end
of file which means that there are no more data on input.<br>
<br>
<table style="text-align: left; background-color: rgb(204, 255, 255); width: 176px; height: 80px; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">$
./mylogin &lt; input.txt</font> <br>
      <span style="color: rgb(255, 0, 0);">No password</span><br>
      <font style="font-size: 9pt;" size="2">Login
: Password :</font><br>
      <font style="font-size: 9pt;" size="2">$</font> </td>
    </tr>
  </tbody>
</table>
<br>
When the operator interacts, he waits for
the display of the password prompt before entering the password. When
the entry is the file <span style="font-style: italic;">input.txt</span>,
the
entired
file
is
entered
at
the
beginning
of
the
program.
So,
the
first
line is read with the first call to <span style="font-style: italic;">fread()</span>
and the
second line is flushed by the call to <span style="font-style: italic;">fseek()</span>.
That's
why
the
second
<span style="font-style: italic;">fread()</span>
encounters an end of file. This is a typical case where the program is
desynchronized with its standard input.<br>
From
this example, we encountered one of the numerous problem we can have
while attempting to automate an interactive program. These kind of
programs also suppose that their standard input and output are
terminals. So, they can trigger some terminal specific operations like
"echo off", "canonical mode", "line mode"... If the input and output
are not terminals but files for example, these operations will fail and
trigger errors in the program.<br>
The pseudo-terminal concept is a solution to those problems.<br>
<br>
<h2><a name="Introduction_to_pseudo-terminals"></a>Introduction
to pseudo-terminals</h2>
A pseudo-terminal is a pair of character mode devices also called <a style="font-style: italic;" href="#1_man_7_pty_">pty</a>.
One is master and the other is slave and they are connected with a
bidirectional channel. Any data written on the slave side is forwarded
to the output of the master side. Conversely, any data written on the
master side is forwarded to the output of the slave side as depicted in
<a href="#Figure_2:_Overview_of_a_pseudo-terminal">figure 2</a>.<br>
<br>
<h6 style="text-align: center;"><span style="text-decoration: underline;"><a name="Figure_2:_Overview_of_a_pseudo-terminal"></a>Figure
2</span>: Overview of a pseudo-terminal</h6>
<div style="text-align: center;"><img style="width: 963px; height: 443px;" alt="figure 2" src="pty_pdip_figure_2.jpg"></div>
<div style="text-align: center;">
<div style="text-align: left;"><br>
The
slave side behaves exactly as a standard terminal as any process can
open it to make it its standard input and outputs. So, all the
operations like disabling the echo, setting the line mode or canonical
mode are available.<br>
The master side is not a terminal. It is just a device which permits to
send/receive data to/from the slave side.<br>
In
the Unix world, there are multiple implementation of the
pseudo-terminals. There are the BSD and the System V versions. The
Linux world recommends the system V implementation also called <span style="font-style: italic;">"Unix 98 pty"</span>. This
is the one we are going to study below.<br>
<br>
<h3><a name="API_of_the_pseudo-terminals"></a>API
of the pseudo-terminals</h3>
The API is quite simple:<br>
<ul>
  <li><span style="color: rgb(255, 0, 0);">posix_openpt()</span><br>
This call creates the master side of the <span style="font-style: italic;">pty</span>. It opens the
device <span style="font-style: italic;">/dev/ptmx</span>
to get the file descriptor belonging to the master side.</li>
  <li><span style="color: rgb(255, 0, 0);">grantpt()</span><br>
The file descriptor got from <span style="color: rgb(255, 0, 0);">posix_openpt()</span>
is passed to <span style="color: rgb(255, 0, 0);">grantpt()</span>
to change the access rights on the slave side: the user identifier of
the device is set to the user identifier of the calling process. The
group is set to an unspecified value (e.g. "tty") and the access rights
are set to <span style="font-weight: bold;">crx--w----</span>.</li>
  <li><span style="color: rgb(255, 0, 0);">unlockpt()</span><br>
After <span style="color: rgb(255, 0, 0);">grantpt()</span>,
the file descriptor is passed to <span style="color: rgb(255, 0, 0);">unlockpt()</span>
to
unlock the slave side.</li>
  <li><span style="color: rgb(255, 0, 0);">ptsname()</span><br>
In order to be able to open the slave side, we need to get its file
name through <span style="color: rgb(255, 0, 0);">ptsname()</span>. </li>
</ul>
To this API, we can mention the standard API of the terminals: <span style="color: rgb(255, 0, 0);">tcgetattr()</span>, <span style="color: rgb(255, 0, 0);">cfmakeraw()</span>...<br>
<br>
The following program called <span style="font-weight: bold; color: rgb(255, 0, 0);">mypty</span>
uses the API to create a pseudo-terminal.<br>
</div>
<div style="text-align: left;">
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 446px; height: 657px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">#define
_XOPEN_SOURCE 600</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;stdlib.h&gt;</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;stdio.h&gt;</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;fcntl.h&gt;</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;errno.h&gt;</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">int
main(void)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">int
fdm;</font> <br>
      <font style="font-size: 9pt;" size="2">int
rc;</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">//
Display /dev/pts</font> <br>
      <font style="font-size: 9pt;" size="2">system("ls
-l /dev/pts");</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">fdm
= <font color="#ff0000"><font style="font-size: 9pt;" size="2">posix_openpt</font></font>(O_RDWR);</font>
      <br>
      <font style="font-size: 9pt;" size="2">if
(fdm &lt; 0)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"Error %d on posix_openpt()\n", errno);</font> <br>
      <font style="font-size: 9pt;" size="2">return
1;</font> <br>
      <font style="font-size: 9pt;" size="2">}</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">rc
= <font color="#ff0000"><font style="font-size: 9pt;" size="2">grantpt</font></font>(fdm);</font>
      <br>
      <font style="font-size: 9pt;" size="2">if
(rc != 0)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"Error %d on grantpt()\n", errno);</font> <br>
      <font style="font-size: 9pt;" size="2">return
1;</font> <br>
      <font style="font-size: 9pt;" size="2">}</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">rc
= <font color="#ff0000"><font style="font-size: 9pt;" size="2">unlockpt</font></font>(fdm);</font>
      <br>
      <font style="font-size: 9pt;" size="2">if
(rc != 0)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"Error %d on unlockpt()\n", errno);</font> <br>
      <font style="font-size: 9pt;" size="2">return
1;</font> <br>
      <font style="font-size: 9pt;" size="2">}</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">//
Display the changes in /dev/pts</font> <br>
      <font style="font-size: 9pt;" size="2">system("ls
-l /dev/pts");</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">printf("The
slave side is named : %s\n", ptsname(fdm));</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">return
0;</font> <br>
      <font style="font-size: 9pt;" size="2">}
// main</font> </td>
    </tr>
  </tbody>
</table>
<br>
The programs lists the content of the directory <span style="font-style: italic;">/dev/pts</span>
at the beginning and at the end to show the creation of the slave side.
In the following example, this is the slave number 4 which is created:<br>
<br>
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 368px; height: 222px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">$
./mypty</font> <br>
      <font style="font-size: 9pt;" size="2">total
0</font> <br>
      <font style="font-size: 9pt;" size="2">crw--w----
1 koucha tty 136, 0 2007-09-25 13:56 0</font> <br>
      <font style="font-size: 9pt;" size="2">crw--w----
1 koucha tty 136, 1 2007-09-25 13:32 1</font> <br>
      <font style="font-size: 9pt;" size="2">crw--w----
1 koucha tty 136, 2 2007-09-25 12:58 2</font> <br>
      <font style="font-size: 9pt;" size="2">crw--w----
1 koucha tty 136, 3 2007-09-25 07:32 3</font> <br>
      <font style="font-size: 9pt;" size="2">total
0</font> <br>
      <font style="font-size: 9pt;" size="2">crw--w----
1 koucha tty 136, 0 2007-09-25 13:56 0</font> <br>
      <font style="font-size: 9pt;" size="2">crw--w----
1 koucha tty 136, 1 2007-09-25 13:32 1</font> <br>
      <font style="font-size: 9pt;" size="2">crw--w----
1 koucha tty 136, 2 2007-09-25 12:58 2</font> <br>
      <font style="font-size: 9pt;" size="2">crw--w----
1 koucha tty 136, 3 2007-09-25 07:32 3</font> <br>
      <font color="#ff0000"><font style="font-size: 9pt;" size="2">crw--w----
1
koucha
tty
136,
4
2007-09-25
13:56
4</font></font> <br>
      <font style="font-size: 9pt;" size="2"><font color="#ff0000"><font style="font-size: 9pt;" size="2">The slave side is named : /dev/pts/4</font></font></font>
      <br>
      <font style="font-size: 9pt;" size="2">$</font> </td>
    </tr>
  </tbody>
</table>
<br>
<h2><a name="Usage_of_the_pseudo-terminals"></a>Usage
of the pseudo-terminals</h2>
A
pseudo-terminal is mainly used to make a process believe that it
interacts with a terminal although it actually interacts with one or
more processes.<br>
<br>
<h3><a name="Inter-process_communication_through_a"></a>Inter-process
communication through a pseudo-terminal</h3>
To point out the pseudo-terminal functions, we can modify <span style="font-weight: bold; color: rgb(255, 0, 0);">mypty</span>
into <span style="font-weight: bold; color: rgb(255, 0, 0);">mypty2</span>.<br>
<br>
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 650px; height: 1872px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">#define
_XOPEN_SOURCE 600</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;stdlib.h&gt;</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;fcntl.h&gt;</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;errno.h&gt;</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;unistd.h&gt;</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;stdio.h&gt;</font> <br>
      <font style="font-size: 9pt;" size="2">#define
__USE_BSD</font> <br>
      <font style="font-size: 9pt;" size="2">#include
&lt;termios.h&gt;</font> <br>
      <br>
      <br>
      <font style="font-size: 9pt;" size="2">int
main(void)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">int
fdm, fds, rc;</font> <br>
      <font style="font-size: 9pt;" size="2">char
input[150];</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">fdm
= <font color="#ff0000"><font style="font-size: 9pt;" size="2">posix_openpt</font></font>(O_RDWR);</font>
      <br>
      <font style="font-size: 9pt;" size="2">if
(fdm &lt; 0)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"Error %d on posix_openpt()\n", errno);</font> <br>
      <font style="font-size: 9pt;" size="2">return
1;</font> <br>
      <font style="font-size: 9pt;" size="2">}</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">rc
= <font color="#ff0000"><font style="font-size: 9pt;" size="2">grantpt</font></font>(fdm);</font>
      <br>
      <font style="font-size: 9pt;" size="2">if
(rc != 0)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"Error %d on grantpt()\n", errno);</font> <br>
      <font style="font-size: 9pt;" size="2">return
1;</font> <br>
      <font style="font-size: 9pt;" size="2">}</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">rc
= <font color="#ff0000"><font style="font-size: 9pt;" size="2">unlockpt</font></font>(fdm);</font>
      <br>
      <font style="font-size: 9pt;" size="2">if
(rc != 0)</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">fprintf(stderr,
"Error %d on unlockpt()\n", errno);</font> <br>
      <font style="font-size: 9pt;" size="2">return
1;</font> <br>
      <font style="font-size: 9pt;" size="2">}</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">//
Open the slave PTY</font><br>
      <font style="font-size: 9pt;" size="2">fds
= open(<font color="#ff0000"><font style="font-size: 9pt;" size="2">ptsname</font></font>(fdm),
O_RDWR);</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">//
Creation of a child process</font><br>
      <font style="font-size: 9pt;" size="2">if
(fork())</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
// Father<br>
      </font>&nbsp;<br>
      <font style="font-size: 9pt;" size="2">&nbsp;
// Close the slave side of the PTY</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
close(fds);</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
while
(1)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
{</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; // Operator's entry (standard input = terminal)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; write(1,
"Input : ", sizeof("Input : "));</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; rc
= read(0, input, sizeof(input));</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; if
(rc &gt; 0)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; {</font><br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; // Send the input to the child process through
the&nbsp;PTY</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; write(fdm,
input, rc);</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; // Get the child's answer through the PTY</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; rc
= read(fdm, input, sizeof(input) - 1);</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; if
(rc &gt; 0)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; {</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; &nbsp; // Make the answer NUL terminated</font>
to display it as a string<br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; &nbsp; input[rc]
= '\0';</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; &nbsp; fprintf(stderr,
"%s", input);</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; }</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; else</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; {</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; &nbsp; break;</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; }</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; }</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; else</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; {</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; break;</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; }</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
}
// End while</font> <br>
      <font style="font-size: 9pt;" size="2">}</font> <br>
      <font style="font-size: 9pt;" size="2">else</font> <br>
      <font style="font-size: 9pt;" size="2">{</font> <br>
      <font style="font-size: 9pt;" size="2">struct
termios slave_orig_term_settings; // Saved terminal settings</font> <br>
      <font style="font-size: 9pt;" size="2">struct
termios new_term_settings; // Current terminal settings</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
//
Child</font><br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
// Close the master side of the PTY</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
close(fdm);</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
//
Save the default parameters of the slave side of the PTY</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
rc
= tcgetattr(fds, &amp;slave_orig_term_settings);</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
// Set raw mode on the slave side of the PTY</font><br>
      <font style="font-size: 9pt;" size="2">&nbsp;
new_term_settings
= slave_orig_term_settings;</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
cfmakeraw
(&amp;new_term_settings);</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
tcsetattr
(fds, TCSANOW, &amp;new_term_settings);</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
// The slave side of the PTY becomes the standard input
and&nbsp;outputs of the child process</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
close(0); // Close standard input (current terminal)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
close(1); // Close standard output (current terminal)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
close(2); // Close&nbsp;standard error (current terminal)</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
dup(fds); // PTY becomes standard input (0)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
dup(fds); // PTY becomes standard output (1)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
dup(fds); // PTY becomes standard error (2)</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
while
(1)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
{</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; rc
= read(fds, input, sizeof(input) - 1);</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; if
(rc &gt; 0)</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; {</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; //
Replace the terminating \n by a NUL to display it as a string</font><br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; input[rc
- 1] = '\0';</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; printf("Child received : '%s'\n", input);</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; }</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; else</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; {</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; &nbsp; break;</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
&nbsp; }</font> <br>
      <font style="font-size: 9pt;" size="2">&nbsp;
}
// End while</font> <br>
      <font style="font-size: 9pt;" size="2">}</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">return
0;</font> <br>
      <font style="font-size: 9pt;" size="2">}
// main</font> </td>
    </tr>
  </tbody>
</table>
<br>
<br>
The program consists of two processes. The father reads a string from
the keyboard and writes it on the master side of the <span style="font-style: italic;">pty</span>. The child
replaced its standard input and outputs by the slave side of the <span style="font-style: italic;">pty</span>. It reads the
slave side and displays what it received on the slave side prefixed by <span style="font-style: italic;">"Child received : "</span>.
Here is an example of execution:<br>
<br>
<table style="text-align: left; background-color: rgb(204, 255, 255); width: 181px; height: 141px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">$
./mypty2</font> <br>
      <font style="font-size: 9pt;" size="2">Input
: azerty</font> <br>
      <font style="font-size: 9pt;" size="2">Child
received : 'azerty'</font> <font style="font-size: 9pt;" size="2"><br>
Input : qwerty</font> <br>
      <font style="font-size: 9pt;" size="2">Child
received : 'qwerty'</font> <br>
      <font style="font-size: 9pt;" size="2">Input
: pwd</font> <br>
      <font style="font-size: 9pt;" size="2">Child
received : 'pwd'</font> </td>
    </tr>
  </tbody>
</table>
</div>
</div>
<a href="#Figure_3:_Description_of_mypty2">Figure 3</a>
depicts the behaviour of the program when the operator enters "qwerty".<br>
<br>
<br>
<br>
<h6 style="text-align: center;"><a name="Figure_3:_Description_of_mypty2"></a>Figure 3:
Description of mypty2</h6>
<br>
<div style="text-align: center;"><img style="width: 1040px; height: 359px;" alt="figure 3" src="pty_pdip_figure_3.jpg"></div>
<span style="font-weight: bold;"><br>
</span>On the slave side we can note the calls to <span style="font-style: italic;">cfmakeraw()</span> and <span style="font-style: italic;">tcsetattr()</span> to
reconfigure the slave side of the <span style="font-style: italic;">pty</span>.
This
sets
the
raw
mode
to
disable
the
echoing
among
other
things.<br>
<br>
We can make <span style="font-weight: bold; color: rgb(255, 0, 0);">mypty2</span>
more generic in order to be able to execute any program
behind the <span style="font-style: italic;">pty</span>
(slave side). In <span style="font-weight: bold; color: rgb(255, 0, 0);">mypty3</span>,
the father process writes all the data from its standard input to the
master side of the <span style="font-style: italic;">pty</span>
and writes all the data from the master side of the <span style="font-style: italic;">pty</span> to its standard
output. The child process behaves the same as in <span style="color: rgb(255, 0, 0); font-weight: bold;">mypty2</span>
but executes an interactive program along with its parameters passed as arguments to the program.
We can note the calls to <span style="font-style: italic;">setsid()</span>
and <span style="font-style: italic;">ioctl(TIOCSCTTY)</span> to make
the <span style="font-style: italic;">pty</span>
be the control terminal of the executed program. We can also note the
closing of the <span style="font-style: italic;">fds</span> file
descriptor which becomes useless after the calls to <span style="font-style: italic;">dup()</span>.<br>
<br>
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 647px; height: 2354px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="white-space: nowrap;">#define _XOPEN_SOURCE 600<br>
#include &lt;stdlib.h&gt;<br>
#include &lt;fcntl.h&gt;<br>
#include &lt;errno.h&gt;<br>
#include &lt;unistd.h&gt;<br>
#include &lt;stdio.h&gt;<br>
#define __USE_BSD<br>
#include &lt;termios.h&gt;<br>
#include &lt;sys/select.h&gt;<br>
#include &lt;sys/ioctl.h&gt;<br>
#include &lt;string.h&gt;<br>
      <br>
      <br>
int main(int ac, char *av[])<br>
{<br>
int fdm, fds;<br>
int rc;<br>
char input[150];<br>
      <br>
// Check arguments<br>
if (ac &lt;= 1)<br>
{<br>
fprintf(stderr, "Usage: %s program_name [parameters]\n", av[0]);<br>
exit(1);<br>
}<br>
      <br>
fdm = <span style="color: rgb(255, 0, 0);">posix_openpt</span>(O_RDWR);<br>
if (fdm &lt; 0)<br>
{<br>
fprintf(stderr, "Error %d on posix_openpt()\n", errno);<br>
return 1;<br>
}<br>
      <br>
rc = <span style="color: rgb(255, 0, 0);">grantpt</span>(fdm);<br>
if (rc != 0)<br>
{<br>
fprintf(stderr, "Error %d on grantpt()\n", errno);<br>
return 1;<br>
}<br>
      <br>
rc = <span style="color: rgb(255, 0, 0);">unlockpt</span>(fdm);<br>
if (rc != 0)<br>
{<br>
fprintf(stderr, "Error %d on unlockpt()\n", errno);<br>
return 1;<br>
}<br>
      <br>
// Open the slave side ot the PTY<br>
fds = open(<span style="color: rgb(255, 0, 0);">ptsname</span>(fdm),
O_RDWR);<br>
      <br>
// Create the child process<br>
if (fork())<br>
{<br>
fd_set fd_in;<br>
      <br>
&nbsp; // FATHER<br>
      <br>
&nbsp; // Close the slave side of the PTY<br>
&nbsp; close(fds);<br>
      <br>
&nbsp; while (1)<br>
&nbsp; {<br>
&nbsp;&nbsp;&nbsp; // Wait for data from standard input and master side
of PTY<br>
&nbsp;&nbsp;&nbsp; FD_ZERO(&amp;fd_in);<br>
&nbsp;&nbsp;&nbsp; FD_SET(0, &amp;fd_in);<br>
&nbsp;&nbsp;&nbsp; FD_SET(fdm, &amp;fd_in);<br>
      <br>
&nbsp;&nbsp;&nbsp; rc = select(fdm + 1, &amp;fd_in, NULL, NULL, NULL);<br>
&nbsp;&nbsp;&nbsp; switch(rc)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case -1 : fprintf(stderr, "Error %d on
select()\n", errno);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exit(1);<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default :<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If data on standard input<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FD_ISSET(0, &amp;fd_in))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = read(0,
input, sizeof(input));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc &gt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Send data on the master side of PTY<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
write(fdm, input, rc);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(rc &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fprintf(stderr,
"Error
%d
on
read
standard
input\n",
errno);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exit(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
      <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If data on master side of
PTY<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FD_ISSET(fdm,
&amp;fd_in))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = read(fdm,
input, sizeof(input));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (rc &gt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //
Send data on standard output<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
write(1, input, rc);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
(rc &lt; 0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
fprintf(stderr,
"Error
%d
on
read
master
PTY\n",
errno);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exit(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; } // End switch<br>
&nbsp; } // End while<br>
}<br>
else<br>
{<br>
struct termios slave_orig_term_settings; // Saved terminal settings<br>
struct termios new_term_settings; // Current terminal settings<br>
      <br>
&nbsp; // CHILD<br>
      <br>
&nbsp; // Close the master side of the PTY<br>
&nbsp; close(fdm);<br>
      <br>
&nbsp; // Save the defaults parameters of the slave side of the PTY<br>
&nbsp; rc = tcgetattr(fds, &amp;slave_orig_term_settings);<br>
      <br>
&nbsp; // Set RAW mode on slave side of PTY<br>
&nbsp; new_term_settings = slave_orig_term_settings;<br>
&nbsp; cfmakeraw (&amp;new_term_settings);<br>
&nbsp; tcsetattr (fds, TCSANOW, &amp;new_term_settings);<br>
      <br>
&nbsp; // The slave side of the PTY becomes the standard input and
outputs of the child process<br>
&nbsp; close(0); // Close standard input (current terminal)<br>
&nbsp; close(1); // Close standard output (current terminal)<br>
&nbsp; close(2); // Close standard error (current terminal)<br>
      <br>
&nbsp; dup(fds); // PTY becomes standard input (0)<br>
&nbsp; dup(fds); // PTY becomes standard output (1)<br>
&nbsp; dup(fds); // PTY becomes standard error (2)<br>
      <br>
&nbsp; // Now the original file descriptor is useless<br>
&nbsp; <span style="color: rgb(255, 0, 0);">close(fds);</span><br>
      <br>
&nbsp; // Make the current process a new session leader<br>
&nbsp; <span style="color: rgb(255, 0, 0);">setsid()</span>;<br>
      <br>
&nbsp; // As the child is a session leader, set the controlling
terminal to be the slave side of the PTY<br>
&nbsp; // (Mandatory for programs like the shell to make them manage
correctly their outputs)<br>
&nbsp; <span style="color: rgb(255, 0, 0);">ioctl(0, TIOCSCTTY, 1)</span>;<br>
      <br>
&nbsp; // Execution of the program<br>&nbsp; {<br>
&nbsp; char **child_av;<br>
&nbsp; int i;<br>
      <br>
&nbsp;&nbsp;&nbsp; // Build the command line<br>
&nbsp;&nbsp;&nbsp; child_av = (char **)malloc(ac * sizeof(char *));<br>
&nbsp;&nbsp;&nbsp; for (i = 1; i &lt; ac; i ++)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; child_av[i - 1] = strdup(av[i]);<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp; child_av[i - 1] = NULL;<br>
&nbsp;&nbsp;&nbsp; rc = execvp(child_av[0], child_av);<br>
&nbsp; }<br>
      <br>
&nbsp; // if Error...<br>
&nbsp; return 1;<br>
}<br>
      <br>
return 0;<br>
} // main<br>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
Below, we launched <span style="font-weight: bold; color: rgb(255, 0, 0);">mypty3</span>
with the calculator <span style="font-style: italic;">bc</span>
as program.<br>
<br>
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 504px; height: 207px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">$
./mypty3</font> <br>
      <font style="font-size: 9pt;" size="2">Usage:
./mypty3 program_name</font> <br>
      <font style="font-size: 9pt;" size="2">$</font> <br>
      <font style="font-size: 9pt;" size="2">$
./mypty3 bc</font> <br>
      <font style="font-size: 9pt;" size="2">bc
1.06</font> <br>
      <font style="font-size: 9pt;" size="2">Copyright
1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.</font> <br>
      <font style="font-size: 9pt;" size="2">This
is free software with ABSOLUTELY NO WARRANTY.</font> <br>
      <font style="font-size: 9pt;" size="2">For
details type `warranty'. </font> <br>
      <font style="font-size: 9pt;" size="2">3+6</font> <br>
      <font style="font-size: 9pt;" size="2">9</font> <br>
      <font style="font-size: 9pt;" size="2">quit</font> <br>
      <font style="font-size: 9pt;" size="2">Erreur
5 on read master PTY</font> <br>
      <font style="font-size: 9pt;" size="2">$</font> </td>
    </tr>
  </tbody>
</table>
<br>
It is possible to launch a shell or any
other interactive program. This behaviour applies to numerous famous
programs like xterm, telnet, ftp, rlogin, rsh... For example, <a href="#Figure_4:_Description_of_a_telnet">figure 4</a>
depicts the architecture of the telnet program.<br>
<br>
<br>
<h6 style="text-align: center;"><a name="Figure_4:_Description_of_a_telnet"></a>Figure 4:
Description of a telnet session</h6>
<div style="text-align: center;"><img style="width: 1021px; height: 430px;" alt="figure 4" src="pty_pdip_figure_4.jpg"></div>
<br>
<br>
The <span style="font-style: italic;">telnetd</span>
process is the father process. Its standard input and outputs are not a
terminal but a network connection to a remote <span style="font-style: italic;">telnet</span> client. The
child process is a <span style="font-style: italic;">bash</span>
shell. All the data coming from the client through the network
connection is forwarded by <span style="font-style: italic;">telnetd</span>
to the master side of the <span style="font-style: italic;">pty</span>.
All
the
data
coming
from
the
<span style="font-style: italic;">bash</span>
shell through the <span style="font-style: italic;">pty</span>
is forwarded by <span style="font-style: italic;">telnetd</span>
to the remote client.<br>
<br>
<h3><a name="Limitation_of_grantpt"></a>Limitation of grantpt()<br>
</h3>
If we read carefully the online manual of <span style="font-style: italic;">grantpt()</span>, it is said that "the behavior of <span style="font-style: italic;">grantpt()</span> is unspecified if a signal handler is installed to catch <span style="font-weight: bold;">SIGCHLD</span> signals". The reason for that can be found by reading its source code in the <span style="color: red;">GLIBC</span>. <span style="font-style: italic;">grantpt()</span> can end with a
      call to <span style="font-style: italic;">fork()</span> to execute <span style="font-style: italic;">chown</span> program while the father (i.e.
      the caller of <span style="font-style: italic;">grantpt()</span>) waits for its termination through <span style="font-style: italic;">waitpid()</span>.
      Hence one cannot capture <span style="font-weight: bold;">SIGCHLD</span> signal otherwise the <span style="font-style: italic;">waitpid()</span> into
      <span style="font-style: italic;">grantpt()</span> will fail. Here is an snippet of the end of the source
      code of grantpt() :<br>

      <br>

      <tt>/* Change the ownership and access permission of the slave
        pseudo</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; terminal associated with the master pseudo terminal
        specified</tt><tt><br>
      </tt><tt>&nbsp;&nbsp; by FD.&nbsp; */</tt><tt><br>
      </tt><b><tt>int</tt></b><b><tt><br>
        </tt></b><b><tt>grantpt (int fd)</tt></b><tt><br>
      </tt><tt>{</tt><tt><br>
        [...]<br>
        &nbsp; /* We have to use the helper program.&nbsp; */<br>
        &nbsp;helper:;<br>
        <br>
        &nbsp; <font color="#ff0000"><b>pid_t pid = __fork ();</b></font><br>
        &nbsp; if (pid == -1)<br>
        &nbsp;&nbsp;&nbsp; goto cleanup;<br>
        &nbsp; else if (pid == 0)<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Disable core dumps.&nbsp; */<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct rlimit rl = { 0, 0 };<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __setrlimit (RLIMIT_CORE, &amp;rl);<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* We pass the master pseudo terminal as file descriptor
        PTY_FILENO.&nbsp; */<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (fd != PTY_FILENO)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (__dup2 (fd, PTY_FILENO) &lt; 0)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _exit (FAIL_EBADF);<br>
        <br>
        #ifdef CLOSE_ALL_FDS<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLOSE_ALL_FDS ();<br>
        #endif<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#ff0000"><b>execle (_PATH_PT_CHOWN, basename
            (_PATH_PT_CHOWN), NULL, NULL);</b></font><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _exit (FAIL_EXEC);<br>
        &nbsp;&nbsp;&nbsp; }<br>
        &nbsp; else<br>
        &nbsp;&nbsp;&nbsp; {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int w;<br>
        <br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#ff0000"><b>if (__waitpid (pid, &amp;w, 0)
            == -1)</b></font><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto cleanup;<br>
        [...]<br>
        <br>
      </tt>So, one should disable any <span style="font-weight: bold;">SIGCHLD</span> handler before calling
      <span style="font-style: italic;">grantpt()</span> and reenable it right after the call.<br>

      
<h3><a name="Taking_control_over_an_interactive"></a>Taking
control over an interactive process</h3>
<span style="color: rgb(255, 0, 0); font-weight: bold;">mypty3</span>
can be more intelligent by making it interpret a command language to
synchronize with the interactive program. In other words, we could
replace the human operator by a script of commands. This is what a
program like<span style="text-decoration: underline;"></span>
<a href="http://pdip.sourceforge.net">pdip</a> does.<br>
<br>
<h2><a name="Presentation_of_pdip"></a>Presentation
of pdip</h2>
<a href="http://pdip.sourceforge.net">pdip</a>
stands for "<span style="font-weight: bold;">P</span>rogrammed
<span style="font-weight: bold;">D</span>ialogue
with <span style="font-weight: bold;">I</span>nteractive
<span style="font-weight: bold;">P</span>rograms".
The acronym PDIP&nbsp;comes from the first lines of the manual of <a href="http://expect.nist.gov">expect</a>.
&nbsp;Like <a href="http://expect.nist.gov">expect</a>,
it interprets a scripting language to dialog with an interactive
program as a human operator would do. But it has not&nbsp;all the
bells
and whistles of <a href="http://expect.nist.gov">expect</a>
which is
able to interact with multiple programs at the&nbsp; same&nbsp;
time,&nbsp; accept a high level scripting language providing
branching
and high level control structures or giving back the control to the
operator during&nbsp; a&nbsp;session. <a href="http://pdip.sourceforge.net">pdip</a> accepts a
very simple language on the input to provide basic functions such as:<br>
<ul>
  <li>Filtering the program&#8217;s output to catch a string matching a
given pattern</li>
  <li>Sending strings of characters to the program</li>
  <li>Stopping interactions with the program during a given
amount of seconds</li>
</ul>
As depicted in <a href="#Figure_5:_Overview_of_pdip">figure
5</a>, <a href="http://pdip.sourceforge.net/">pdip</a>
receives as parameter the name of the interactive program to control.
The commands are entered either through the standard input or from a
script passed on the command line.<br>
<br>
<h6 style="text-align: center;"><a name="Figure_5:_Overview_of_pdip"></a>Figure
5:
Overview
of
pdip</h6>
<div style="text-align: center;"><img style="width: 910px; height: 420px;" alt="figure 5" src="pty_pdip_figure_5.jpg"></div>
<br>
<br>
pdip accepts the following commands:<br>
<br>
<div style="margin-left: 40px;">#...&nbsp; # and the
following words up to the end of line are ignored (used for comments)<br>
</div>
<br>
<div style="margin-left: 40px;">dbg level<br>
<div style="margin-left: 40px;">Set&nbsp; the debug level to level.&nbsp; The higher the level, the more traces you get. The value 0 deactivates the debug mode.<br>
</div>
timeout x<br>
<div style="margin-left: 40px;">Set
to x seconds the maximum time to wait on each following&nbsp;
commands&nbsp; (the&nbsp; value&nbsp; 0 cancels the
timeout, this is
the default)<br>
<br>
</div>
recv "w1 w2..."<br>
<div style="margin-left: 40px;">Wait&nbsp;
for&nbsp; a line with the pattern w1 w2...&nbsp; from the
program. The
pattern is regular expression conforming to <a href="#2_man_7_regex">regex(7)</a>.<br>
<br>
</div>
send "w1 w2..."<br>
<div style="margin-left: 40px;">Send the string w1
w2...&nbsp; to the program. The string may contain the&nbsp;
following&nbsp; control characters:<br>
<br>
<div style="margin-left: 40px;">\a Bell<br>
\b Backspace<br>
\t Horizontal tabulation<br>
\n New line<br>
\v Vertical tabulation<br>
\f Form feed<br>
\r Carriage return<br>
\" Double quote<br>
\\ Backslash<br>
\[ Escape<br>
\] Group separator<br>
\^ ^ character<br>
</div>
</div>
sleep x<br>
<div style="margin-left: 40px;">Stop activity during x
seconds<br>
</div>sig signame<br>
<div style="margin-left: 40px;">Send&nbsp; the&nbsp; Linux&nbsp; signal
signame to the program. signame is one of: HUP, INT, QUIT, ILL, TRAP,
ABRT, BUS, FPE, KILL, USR1, SEGV, USR2, PIPE, ALRM, TERM.<br>
</div>
sh [-s] cmd par...<br>
<div style="margin-left: 40px;">Launch the cmd par...&nbsp; shell command (synchronously if -s is specified).<br>
</div>
exit<br>
<div style="margin-left: 40px;">Terminate PDIP<br>
</div>
</div>
<br>
<h3><a name="Using_pdip"></a>Using pdip</h3>
Using
pdip is straightforward as we can see with the control of a telnet
client which connects to a &nbsp;host&nbsp; called
&#8217;remote&#8217;&nbsp; on&nbsp; the&nbsp; TCP&nbsp; port 34770
with
the login name &#8217;foo&#8217; and password &#8217;bar&#8217;.&nbsp;
Since the remote port is specified with an option (-p), it is mandatory
to put a double&nbsp; hyphen (--) before the command to
launch.&nbsp;
Commands are injected on the standard input. We wait for the
&#8217;$&#8217; prompt and launch the ls(1) command before
disconnecting from the shell via the exit command.<br>
<br>
<div style="margin-left: 40px;"><span style="font-family: monospace;">$
pdip -- telnet -p 34770
remote</span><br style="font-family: monospace;">
<span style="font-family: monospace;">recv "login"</span><br style="font-family: monospace;">
<span style="font-family: monospace;">send
"foo\n"&nbsp;&nbsp; # Login name is &#8217;foo&#8217;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">recv "Password"</span><br style="font-family: monospace;">
<span style="font-family: monospace;">send
"bar\n"&nbsp;&nbsp; # Password is &#8217;bar&#8217;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">recv "\$
"&nbsp;&nbsp;&nbsp;&nbsp; # Inhibition of the
metacharacter &#8217;$&#8217; with &#8217;\&#8217;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">send
"ls\n"&nbsp;&nbsp;&nbsp; # Launch the &#8217;ls&#8217; command</span><br style="font-family: monospace;">
<span style="font-family: monospace;">recv "\$ "</span><br style="font-family: monospace;">
<span style="font-family: monospace;">send
"exit\n"&nbsp; # Exit from the shell</span><br style="font-family: monospace;">
<span style="font-family: monospace;">exit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
#
Exit
from
PDIP</span><br style="font-family: monospace;">
<span style="font-family: monospace;">$</span><br>
</div>
<br>
We
can note that it is mandatory to quote the "$" sign on the recv command
as it is a metacharacter meaning end of line. Here is an example of
execution:<br>
<br>
<table style="text-align: left; font-family: monospace; background-color: rgb(204, 255, 255); width: 536px; height: 462px;" border="1" cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td> <font style="font-size: 9pt;" size="2">$
pdip -- telnet -p 34770 remote</font> <br>
      <font style="font-size: 9pt;" size="2"><font color="#ff0000"><font style="font-size: 9pt;" size="2"><font color="#ff0000">recv
"login <span style="font-family: monospace;">"</span></font></font></font></font>
      <br>
      <font style="font-size: 9pt;" size="2">Trying
192.0.1.12...</font> <br>
      <font style="font-size: 9pt;" size="2">Connected
to remote.</font> <br>
      <font style="font-size: 9pt;" size="2">Escape
character is '^]'.</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">Linux
2.6.22-14-generic (remote) (pts/10)</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">remote
login<font color="#ff0000"><font style="font-size: 9pt;" size="2"><font color="#ff0000">send
"foo\n"</font></font></font></font> <br>
      <font style="font-size: 9pt;" size="2"><font color="#ff0000"><font style="font-size: 9pt;" size="2"><font color="#ff0000">recv
"Password"</font></font></font></font> <br>
      <font style="font-size: 9pt;" size="2">:
foo</font> <br>
      <font style="font-size: 9pt;" size="2">Password<font color="#ff0000"><font style="font-size: 9pt;" size="2"><font color="#ff0000">send
"bar\n"</font></font></font></font> <br>
      <font style="font-size: 9pt;" size="2"><font color="#ff0000"><font style="font-size: 9pt;" size="2"><font color="#ff0000">recv
"\$ "</font></font></font></font> <br>
      <font style="font-size: 9pt;" size="2">: </font> <br>
      <font style="font-size: 9pt;" size="2">Last
login: Tue Nov 6 20:06:51 CET 2007 on :0</font> <br>
      <font style="font-size: 9pt;" size="2">Linux
remote 2.6.22-14-generic #1 SMP Sun Oct 14 23:05:12 GMT 2007 i686</font>
      <br>
      <br>
      <font style="font-size: 9pt;" size="2">The
programs included with the Ubuntu system are free software;</font> <br>
      <font style="font-size: 9pt;" size="2">the
exact distribution terms for each program are described in the</font> <br>
      <font style="font-size: 9pt;" size="2">individual
files in /usr/share/doc/*/copyright.</font> <br>
      <br>
      <font style="font-size: 9pt;" size="2">Ubuntu
comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</font> <br>
      <font style="font-size: 9pt;" size="2">applicable
law.</font> <br>
      <font style="font-size: 9pt;" size="2">foo@remote:~$ <font color="#ff0000"><font style="font-size: 9pt;" size="2"><font color="#ff0000">send
"ls\n"</font></font></font></font> <br>
      <font style="font-size: 9pt;" size="2"><font color="#ff0000"><font style="font-size: 9pt;" size="2"><font color="#ff0000">recv
"\$ "</font></font></font></font> <br>
      <font style="font-size: 9pt;" size="2">ls</font> <br>
      <font style="font-size: 9pt;" size="2">DIR2
DOCUMENTS PERSO TODO</font> <br>
      <font style="font-size: 9pt;" size="2">Applications
PHOTOS VIDEOS</font> <br>
      <font style="font-size: 9pt;" size="2">foo@remote:~$ <font color="#ff0000"><font style="font-size: 9pt;" size="2"><font color="#ff0000">send
"exit\n"</font></font></font></font> <br>
      <font style="font-size: 9pt;" size="2"><font color="#ff0000"><font style="font-size: 9pt;" size="2"><font color="#ff0000">exit</font></font></font></font>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<h2><a name="Resources"></a>Resources</h2>
<a name="1_man_7_pty_"></a>[1] man 7 pty<br>
<a name="2_man_7_regex"></a>[2] man 7 regex<br>
[3]
Programmed Dialogues with Interactive Programs (<a href="http://pdip.sourceforge.net/">PDIP</a>)<br>
[4] Utilisation des pseudo-terminaux pour piloter les programmes
interactifs - <a href="http://www.unixgarden.com/index.php/programmation/utilisation-des-pseudo-terminaux-pour-piloter-les-programmes-interactifs"><img alt="glmf_logo" src="../glmf_logo.jpg" style="border: 0px solid ; width: 100px; height: 30px;"></a>
(in french)<br>
[5] <a href="http://www.tset.de/lpty/">lpty - PTY control for Lua</a><br>
<br>
<br>
<h2><a name="About_the_author"></a>About the
author</h2>
The author is an engineer in computer sciences located in France. He
can be contacted <a href="http://rachid.koucha.free.fr/contact/contact.html">here</a> or
you can have
a look at his <a href="http://rachid.koucha.free.fr/">WEB
home page</a>.<br>
<br>
<table style="text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(192, 192, 192);">
  <tbody>
    <tr>
      <td>
      <script type="text/javascript"><!--
google_ad_client = "pub-9113501896220746";
/* 728x90, date de création 29/03/08 */
google_ad_slot = "7632855209";
google_ad_width = 728;
google_ad_height = 90;
//--></script>
      <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<div style="text-align: right;"><small><a href="http://rachid.koucha.free.fr/index.html">Back to home
page</a></small><br>
<small><a href="../technical_documents.html">Back to
previous
page</a></small><br>
</div>
<br>
</div>
</div>
<br>
<br>

</body></html>